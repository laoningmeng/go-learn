# 数组和切片



## 1. 什么是数组

数组是一个集合概念用于存放同一种数据类型的值， 数组的长度是一旦定义是不可变的。

这里需要注意的是`[1]string` 和`[2]string` 是两种数据类型



## 2. 什么是切片

切片是基于数组实现的长度可变的数据类型. 切片的容量会随着元素的增多而变大，但是不会因为元素的减少而变小。 可以把切片看出是对数组的引用， 所以这个数据是引用传递的类型。





## 3. 定义数组和切片

定义数组

```go
var b  [1]string
b = [1]string{"a"}
```



定义切片

```go
var a []string
a = []string{"a","b"}
var c = make([]string, 5,5)
```

这里需要说明一下这个make ， 它是用来进行类型初始化的，而他能够使用的类型也是有限的，有`slice`, `map` `chan` 仅有这三种可以用make， make 在不指定容量的时候，长度和容量默认相等

## 4. 长度和容量

```go
var arr = [2]int{1, 2}
var s = arr[:]
fmt.Println(cap(arr), cap(s), len(arr), len(s))
```

`len`函数可以获取到切片，数组中元素数量

`cap` 函数可以获取到切片，数组的容量， 对于slice 来说这个cap指的是他底层数组的长度。





## 5. 切片的创建方式

相比数组来说，切片的定义方式会多一些。

* 通过make创建

 ```go
  var s = make([]string, 2,8)
 ```

* 直接定义赋值

```go
var s []string = []string{"a","b"}
var s = []string{"a","b"}
```

* 基于已经存在的数组切片处理

```go
var arr = [3]int{1, 2, 3}
var s = arr[:]
fmt.Println(s) // [1 2 3]
arr[2] = 4
fmt.Println(s) //[1 2 4]


s1 := arr[0:1]
fmt.Println(s1) //[1]
```

通过上面的例子，我们可以看出以下几点，首先 切片是值引用， 如果底层的数据发生变化， 切片会跟着动。其次，通过`:` 来进行数组截取切片是左闭右开的区间









## 6. 存储器及cpu对他的读写

想要让cpu工作就必须向他提供数据和指令，而数据和指令的存储位置就是存储器，也就是我们常说的内存。

* 指令和数据是应用概念， 对计算机来说他们都是二进制数字
* 存储器被划分成了若干存储单元，这个单元就是我们常说的字节， 存储单元从0开始顺序编号，这些编号可以看成存储器的内存地址。这里需要注意一下，我们虽然对内存进行了划分，但不是每个位置都存储他的地址信息（可以想象一下，一个存储单元1个byte ，而要存储他的地址可能需要4个字节），对于如何去找的对应的地址，则需要寻址总线了。
* 地址总线： 如果地址有8根，说明一次寻址0-2^8-1的范围， 地址总线的宽度决定了寻址速度
* 数据总线：内存和其他元器件的数据传输， 如果有8根，一次传输一个字节，同样，数据总线宽度决定数据传输速度
* 控制总线：决定了cpu对其他器件的控制能力







## 7. 查看一下变量的位置



下面介绍一下printf的用法

* `%+v` 如果值是一个结构体会输出内容，包含字段名称
* `%T` 打印值的类型
* `%d`  标准的十进制格式化
* `%b` 二进制表示
* `%c` 输出给定整数的字符，如100->d
* `%x` 十六进制表示
* `%s` 进行基本字符输出
* `%p` 要打印一个指针的值

```go
var arr = [3]int{1, 2, 3}
s1 := arr[0:1]
fmt.Printf("s1的内存地址？%p \n", s1)
fmt.Printf("s1 指针的指针地址：%p \n", &s1)
fmt.Printf("arr 的内存地址？%p \n", &arr)
fmt.Printf("arr[0] 的内存地址？%p \n", &arr[0])

s2 := arr[1:2]
fmt.Printf("s2的内存地址？%p \n", s2)
fmt.Printf("arr[1]的内存地址？%p \n", &arr[1])
/**
s1的内存地址？0xc0000160c0 
s1 指针的指针地址：0xc00000c030 
arr 的内存地址？0xc0000160c0 
arr[0] 的内存地址？0xc0000160c0 
s2的内存地址？0xc0000160c8 
arr[1]的内存地址？0xc0000160c8 
*/
```



这里需要说明一下， 对`s1` 活着`s2`来说，指向这个变量的的内存地址都是一个元素，因为他们是结构体， 所以指向的是第一个array 的地址（见下面的结构）， 其实我们去取地址`&s1` 其实就是对`&array` ， 而切片里的`array 字段`本身就是一个指针，如果再次去取地址，取到的不是指针指向的数组地址，而是指针变量的地址。 



## 8. 切片的底层原理

`src/runtime/slice.go`

```go
type slice struct {
	array unsafe.Pointer // 这个Pointer可以转换成任意类型的指针
	len   int
	cap   int
}
```



因为是引用类型，所以我们在对切片进行修改的时候，他的底层array 也会被改动

```go
var arr = [3]int{1, 2, 3}
	s1 := arr[0:1]
	s1[0] = 99
	fmt.Println(s1) //[99]
	fmt.Println(arr) //[99 2 3]
```



## 9. 切片元素删除和动态扩容



